# わからなかった単語・調べた単語をすぐに検索できるページ

## SwiftUI
SwiftUI は、宣言型の状態駆動型フレームワークです。

## KVO(Key Value Observe)
Key Value Observe の略のことです。
>「キー値監視」と訳されている (Swiftのプロパティ監視とは別）
>オブジェクトの属性値の監視をプロパティを通してではなく、キー(文字列、#keyPath式)を使って行うことができる
>通知を受け取る方も通知する方もNSObjectを継承する
>NSKeyValueObserving プロトコルが自動的に適合される(引用:https://qiita.com/ysn/items/9ca0248362f47d563f38)


## SoC Separation of concerns 関心の分離
コンピュータプログラムを異なるセクションに分割し、各セクションが別々の問題に対処する設計原理のことです。
5 つの SOLID 原則（単一責任とインターフェイス分離）のうち 2 つが、この概念から直接派生していることが非常に重要です。

## @Binding
SwiftUI では、変数を参照型として扱うための Binding という型があります。
@Binding は、Binding 型を扱うための PropertyWrapper です。
つまり、@Binding と Binding は明確には異なるものです。

## VIPER

- View: View と ViewController
- Interactor: API 通信担当
- Presenter: 自分以外の中継役
- Entity: データそのもの
- Router: 画面遷移担当

## Presenter
View と Router、Interactor の３つと関係しています。
依存しているのは、Router と Interactor の 2 つで、View からは依存されています。そのため Presenter は View のことは何も知らずただ View(Button やタップなど)に命令されたことに従うウェイターさんのような仕事をこなします。
- View から受け取ったイベントを別クラスに依頼
- View に対して画面更新を依頼
- Interactor に対してデータの取得を依頼
- Router に対して画面遷移を依頼

```swift
final class PostsListPresenter: ObservableObject {
    struct Parameter {
        let frogs: [Post]
    }
    enum Inputs {
        case didTapAboutButton
    }
    private let router = PostsListListRouter()
    let params: Parameter
    @Published var isShowAbout = false
    init(params: Parameter) {
        self.params = params
    }
}
```


## @StateObjectと@ObservedObjectの違い

@StateObject は親の画面更新によって状態が変化せずに、値が保持される。


## VStackとLazyVStackの違い
「Lazy」が付いていない HStack・VStack との違いは「必要な分だけ読み込む」ところです。
LazyHStack や LazyVStack は画面に表示される分だけ順次メモリにロードしてくれます。


## Conpletionの処理を関数にして切り分ける

```swift

//completionの時
private func onReceive(_ completion: Subscribers.Completion<Error>) {
    switch completion {
    case .finished:
        break
    case let .failure(error):
        print(error.localizedDescription)
    }

}
private func onReceive(_ batch: [RecruitData]) {
    state.responses += batch
    state.page += 1
    state.canLoadNext = batch.count > 50
}


```


## スタブ
スタブ = 事前に設定した振る舞いをする偽物のオブジェクト。特に、取得用のオブジェクトとして利用する。

テスト時のみ、返ってくる値を固定値にする(= 返ってくる値が明確)
クラス外とのやりとりは Protocol を通すことで、実際の実装との関係を切り離す
大域変数と直接やりとりを行わないようにし、大域変数への変更は最小限にとどめること。


https://qiita.com/yokoyas000/items/327fb2b481738fac4c5a


## XCTest
XCTest は、ユニットテストや UI テストの実行環境を提供します。
テストという行為は品質保証を支援することにある。
テストの自動化を行うことで、人の手作業の誤り・失敗を減らすなどを実現することが容易になる。

- iOS Unit Testing Bundle
  - ユニットテスト用
- iOS UI Testing Bundle
  - UI テスト用

ターゲット作成時のテンプレートとして用意されている。


## GEMS（Generic Error-Modeling System）
失敗には２つの種類が存在していて、1 つは実行。 2 つは、計画が不適切という分け方。
人は、滅多に発生しないことを効率的に発見することが難しい生き物です。
自動化されたテストによる恩恵は大きいものの、テストコードやその実行環境の整備に対して向き合う必要があります。

## どんなところをテストするのが効果的か？
- 開発中にあまり触れない、設定画面や規約などの変化の少ない箇所
- 障害発生時に十分に考慮できている必要のある機能（たとえば障害時のみに表示されるダイアログなど）
- 自動化でないと操作が面倒な範囲
- 端末設定や言語などの環境の切り替えの組み合わせ

##　テストをする上でのポイント
「1. 自動化」され「2. 繰り返し実行可能」で「3. 統一的な仕組み」に支えられたテストが重要です。


## AAA パターン(Arrange Act and Assert)


1. 状態の準備 (Arrange)
2. 操作を行う (Act)
3. 結果の検証 (Assert)

このようにテストを３つのフェーズにわけて考える方法は、AAA パターンと呼ばれます。

## Four-Phase Test
「setup」「exercise」「verify」「teardown」
このテストはグローバルなデータベースに変化を与える時に、後片付けを行うことを考慮したテストのことです。


## テストダブルについて
オブジェクト指向(OO)プログラミングで書かれたコードに対してユニットテストをする際の必須のテクニックのことです。
ユニットテストを行う時にオブジェクト同士の依存関係が問題になることがある。そのため、テスト対象の依存するオブジェクトをテスト用にして都合の良い振る舞いをするものに置き換えることで、実際にテストをしたいオブジェクトをテストできるようになります。
依存関係を外部から注入するテクニックを DI（Dependency Injection）と呼ぶ。


## DI (Dependency Injection)について
DI には３つの種類があると言われています。
- フィールドインジェクション
- セッターインジェクション
- コンストラクタインジェクション

フィールドインジェクションよりコンストラクタインジェクションが推奨されているようです。
https://pppurple.hatenablog.com/entry/2016/12/29/233141#:~:text=%7D-,%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF%E3%83%BB%E3%82%A4%E3%83%B3%E3%82%B7%E3%82%99%E3%82%A7%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8B%E3%82%99%E6%8E%A8%E5%A5%A8%E3%81%95%E3%82%8C%E3%82%8B%E8%A6%B3%E7%82%B9,-%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF

## 推奨されている理由
- 単一責任の原則に則っているかわかりやすくなること
  - 依存関係が多いということは適切にクラスを切り分けられていないことの指標になる
- 依存関係の明示
  - そのクラスの構成要素が外から見られるため、何をしているのか大体わかる
- Immutability(不変性)
  - コンストラクタインジェクションではフィールドを final, let として宣言でき、インスタンスを外から依存されることがない
  
それぞれの DI についてのメリット・デメリットを知りながら適切に判断することが重要ですね。


## テストダブルの分類　Test Double

- スタブ
  - 都合の良い値を返す
- モック
  - 依存コンポーネントに対するメソッド呼び出しやプロパティのアクセスについて、その呼び出し回数や引数の値を記録するもの
  テスト対象と正しくコミュニケーションを取ったかについて検証できます。
- スパイ
  - モックと同じだが、実際の依存コンポーネントを使用して、アクセスの記録のみを行います。
- フェイク
  - 実際の依存コンポーネントと同等か極めてそれに近い挙動を持つものを、代わりに利用するものです。
- ダミー
  - テスト対象のコンポーネントとは関係がなく、ただコンパイルを通すためだけに作るものです。



## Cuckoo 
自動生成型のモックライブラリ
https://github.com/Brightify/Cuckoo

## HTTPスタブ
外部との HTTP 通信するクラスについて、レスポンスが正しくパースできることを確認するユニットテストを書いたり、
テスト用のダミーレスポンスを使って UI テストをするのに役立ちます。


## アサーションメソッド
expression を exp と略す。


## XCTestのライフサイクル

Singleton やデータベースなどの永続的なデータを扱うコンポーネントには tearDown()後処理を行うことが重要です。

## テストのランダマイズ化
Edit Scheme -> Test -> Options -> Randomize execution order からテスト実行順序のランダム化を行うことができる。

## 非同期のテスト
### 非同期のテストを行うために必要なもの
- `XCTestExpectation(description: String)`
- `wait(for: [XCTestExpectation], timeout: second)`

クロージャーの中に `XCTestExpectation.fulfill()` を入れる。


## コンストラクタインジェクション
コンストラクタインジェクションは、コンポーネントの初期化時に依存するコンポーネントを代入する DI です。

## セッターインジェクション
コンポーネントのイニシャライズ以降にセッターメソッド、あるいは外部に公開されたプロパティに対して依存するコンポーネントを代入する DI です。
セッターインジェクションは代入忘れを起こす可能性があるため、可能な限りコンストラクタインジェクションを使っていくのがベターです。

## スタブ
1. プロトコルの定義
2. プロトコルを継承したスタブクラスを定義
3. Manager や ViewModel などでプロトコルをプロパティーに宣言

実際に使用します。

## 振舞駆動開発(BDD)
- Given　あるコンテキストでテストを与えて
- When　テスト対象に何かが起こる時
- Then  ある結果が期待される
という 3 つの要素に分けて仕様を記述する。

## Quickの基本
describe,context,it を使った Quick の基本です。

## Nimbleの基本
入力は「期待値」と「結果」の 2 つです。

```
expect(＜検証する式＞).to(＜期待する結果＞)
```


## リアクティブプログラミング
アプリの非同期処理を行うために必要なライブラリは Foundation や UIkit などでは、Delegate,Notification Center,GCD Grand Central Dispatch, Callback などが使われている。
これらとは異なる手法で非同期処理を実現しているリアクティブプログラミングという方法がある。

## Dispatch Queue（直訳：送信待ち行列？）
処理待ちタスクを追加するためのキュー。追加された順にタスクを処理側へ渡す役割を担う。タスクの処理は担当しない。
## Main DispatchQueue
OS 側で作成済みなので呼び出すだけ。
1 つだけ存在。
直列処理タイプ。
UI 表示系タスクはここで行わないと動かない。

## Grobal DispatchQueue
OS 側で作成済みなので呼び出すだけ。
5 つ存在。（ただし、実質使えるのは 4 つ）
並列処理タイプ。
用途を指定して呼出し。

その他のディスパッチキューについて詳しく書かれた記事
https://qiita.com/ShoichiKuraoka/items/bb2a280688d29de3ff18

## Operator
ある Publisher を別の Publisher に変換するメソッドを、Combine の用語で「Operator」と呼びます。
- map
- filter
- compactMap
- combineLatest などがある

## Combineについて
SwiftUI は内部的に Combine を活用しています。



## Swift のエラー4分類

### 関数の呼び元で回復可能だと判断される場合
- Simple Domain Error:原因が明白なので、 nil を返す
- Recoverable error:原因によって回復手段が異なると考えられるため、Error を throw
### 関数の呼び元で回復不能だと判断される場合
- Universal error:プログラムを停止させるべきであり、 fatalError() する
- Logic failure:呼ぶ側のバグだとして、 precondition を使って正しい事前条件を明示


## 2つのデータの同期方法

### フロー同期
となりあった画面の状態を次の画面に渡す同期方法のことです。

### オブザーバー同期
参照元のオブジェクトの状態をオブザーブして参照先にその変化を同期する方法。オブザーバー同期はデータが変更されるたびに同期処理が実行されるため、いつデータが同期されるかが追いづらいデメリットがある。
しかし、共通した監視先を持つ複数の箇所で、データが同期できるメリットなどもあるため、使い方を分けることが重要です。


## MVP
MVP には 2 種類の考え方がある。PassiveView と Supervisiong Controller です。

### PassiveView
View に描画処理の実装を持たせるのみにしておき、描画指示を Presenter に任せることでプレゼンテーションロジックのテストを行いやすくなる点がメリットです。
各コンポーネントのデータのやりとりはフロー同期によって実現される。
Presenter は 1 つの View に対して、1 つ作成する。iOS においては、一般的に VC の存在が不可欠であるため、View が Presenter のことを知っており、Presenter は View を weak3 章で持つようにする。


### Supervisiong Controller

## OOP とは何か？
Object Oriented Programming の略で、日本語ではオブジェクト指向プログラミングと呼ばれるもの。
OOP を理解するには、プログラミングの背景を知ることでより深い理解を深めることができます。

### プログラミングの歴史
コンピュータが初めて登場したのは 1940 年代のころで、その当時は、Python や C 言語などは存在しておらず、プログラマ自身が機械語を使って 1 行 1 行プログラムを書く必要がありました。
無機質だった機械語を人間が理解しやすい記号に置き換えるアセンブリ言語が登場し、プログラムを書き換えることが機械語時代より楽になりました。が命令を少し間違えただけで、プログラムが暴走してしまうという問題がありました。
そこで、高級言語というものが発明され、プログラミングはより人間に近づきました。
高級言語は、コンピュータが理解しやすい命令ではなく人間が理解しやすい命令を書くことができる言語で、1950 年代にはすでに考案されていました。
今でも現役で使われている FORTRAN もこの時代に誕生した言語です。
また、この時代からソフトウェア開発をもっとわかりやすく、正しく動作させるためのプログラム言語が生まれました。

そんな中、構造化プログラミングという概念が生まれ、今まで、プログラミングを複雑化していた主な要因である、GOTO 文が廃止されるなどして言語として発展していきました。
メソッド(サブルーチン)などの概念もその中で生まれました。しかし、プログラムの保守性をあげる上で、関数の独立性が重要な課題となってきました。

### 構造化プログラミングで残された課題
構造化プログラミングで解決できたこととして、GOTO 文によるコードの複雑性と共通メソッドによる再利用などが挙げられます。
しかし、共通メソッドを利用するためのグローバル変数や、貧弱な再利用という問題が残されました。
ソフトウェアはどんどん肥大化するため、より大規模な再利用が求められます。
そこで OOP が登場します。初めに登場した言語は 1967 年の Simula67 という言語でした。しかし、ハードウェアの能力不足のためこの時代にはあまり活躍はできませんでした。
OOP が活躍し始めたのは,1990 年代の Java が登場してからの話です。

ソフトウェアアーキテクトの世界では答えは明らかで、OO とは「ポリモーフィズム」を使用することで、システムのソースコードの依存関係を絶対的に制御する能力のことです。

上位レベルと下位レベルのモジュールを独立させて開発できる。



## 暗黙的な変数,予約語
Swift には暗黙的な変数が存在します。
例えば do catch 内に存在する error です。

```swift
do {
  throw fatalError()
} catch {
  print(error)
}

```

他にも、set の newValue、self などもあります。
特に error は独自で定義した error とかぶる可能性高いため注意してください。


## C++の書き方
ベクトルの3つの宣言方法

```cpp
vector<int> v_1{0, 1, 2};
vector<int> v_2 = {3, 4, 5};
vector<int> v_3;
v_3 = {6, 7, 8};
```

## Node.jsについて
Node.jsはJavaScriptランタイムです。
JavaScriptコードが実行できる開発環境ということ
JavaScriptは、ブラウザで実行するように設計されたスクリプト言語で、それをPC上で実行できるようにしたものがNode.js

Node.jsは、同時実行タスクに対して 1 つのイベント ループが使用される。


## バージョン記法について

- メジャー バージョン
  - 左端の数値。 たとえば、1.0.0 の 1 です。 この数値に対する変更は、コードに破壊的変更があると予想されることを意味します。 場合によっては、コードの一部を書き直す必要があります。
- マイナー バージョン
  -  真ん中の数値。 たとえば、1.2.0 の 2 です。 この数値に対する変更は、機能が追加されたことを意味します。 コードは引き続き機能します。 通常は更新を受け入れても安全です。
- パッチ バージョン
  - 右端の数値。 たとえば、1.2.3 の 3 です。 この数値に対する変更は、コード内で動作する必要があるものを修正する変更が適用されたことを意味します。 更新を受け入れても安全です。


  ## VSCodeのデバック
MicrosoftのVSCodeの使い方を説明した記事が役に立ちます。
デバック方法を詳しく説明しています。
  https://docs.microsoft.com/ja-jp/learn/modules/debug-nodejs/5-analyze-your-program-state

  https://code.visualstudio.com/docs/editor/debugging


## URLとルーティング
URLは１つのアドレスです。
>  scheme:[//authority]path[?query][#fragment]

### Scheme
URL のスキーム部分はプロトコルを示します。 一般的な URL の例では、スキームは http です。 その他のスキームの例として、https、ftp、irc、file があります。

### Authority
オーソリティは、オプションのユーザー情報 (username@password) とホストで構成されます。 例の URL で、localhost はホスト部分であり、ご自身のコンピューターを Web サーバーとして指しています。 Web では、ホスト部分は通常、google や microsoft のようなドメイン名です。

ホストは、IP アドレスの代わりに指定するフレンドリ名です。 IP アドレスは実際の Web アドレスです。 127.0.0.1 のような一連の数値です。 IP アドレスにより、ルーターによって、Web のある部分から別の部分へ要求を簡単に "ルーティング" できるようになります。 ただし、人間にとってはわかりやすいものではありません。 ホストとドメイン名は、それらを覚えやすくするために存在します。

### Path
URL のパス部分は、0 個以上のセグメントで構成されます。 各セグメントは、スラッシュ (/) で区切られます。 例の URL では、セグメントは /products のみです。 セグメントを使用して、リソースの対象となる部分に正確に絞り込みます。

### クエリ
クエリは、疑問符 (?) 文字の後に定義されている URL の省略可能な部分です。 これは、アンパサンド (&) またはセミコロン (;) で区切られた、クエリ パラメーターと値のペアで構成されます。 特定のページのレコード数を指定することで、データをさらに絞り込みます。

例の URL でのクエリは ?page=1&pageSize=20 です。 リソースに 200 万件のレコードがあるとします。 すべてのレコードが返されるまでには長い時間がかかります。 20 個のレコードが必要であることを指定した場合、データは迅速に返され、サイズは小さくなります。

### Fragment
URL のフラグメント部分は、さらに具体的に指定するために役立ちます。 たとえば、フラグメントを使用して、要求したデータを特定の順序で並べ替えることができます。