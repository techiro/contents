# オブジェクト指向プログラミングで重要な性質

- カプセル化
- 継承
- ポリモーフィズム

## カプセル化

カプセル化は、クラスの宣言と定義を分離することです。

## 継承

```swift

func abstructPolymorphism() {

    class Animal {
        func greeting() -> String {
            return "";
        }
    }


    class Cat: Animal {
        override func greeting() -> String {
            return "にゃあー"
        }
    }

    class Dog: Animal {
        override func greeting() -> String {
            return "ワン！"
        }
    }

    let catAndDog = [
        Cat(),
        Dog()
    ]

    catAndDog.forEach { animal in
        print(animal.greeting())
    }


}

abstructPolymorphism()

```

## OO とは何か？

ソフトウェアアーキテクトの世界では答えは明らかで、OO とは「ポリモーフィズム」を使用することで、システムのソースコードの依存関係を絶対的に制御する能力のことです。

上位レベルと下位レベルのモジュールを独立させて開発できる。

## 依存関係逆転

ソースコードの依存関係と制御の流れは必ずしも同じでなくても良い。
依存の関係は UML の矢印で表すことができる。
ソースコードの依存関係はどこにあっても逆転できる。
システムにあるソースコードの依存関係の方向を絶対的に制御できる。
依存関係を制御の流れに合わせる必要がなくなる。

![依存関係逆転](../images/20210728_11.20.png)

ビジネスルールを含むコンポーネントは UI やデータベースを含むコンポーネントに依存しない。
逆に UI と DB はビジネスルールに依存している。

![UIとDBはビジネスルールに依存](../images/20210728_11.28.png)

## 関数型言語

関数型言語の特徴として、普遍性がある。

## 可変性の分離

サービスを可変コンポーネントと不変コンポーネントに分離することが１つのソフトウェアアーキテクトとして挙げられる。

- 不変コンポーネントは、可変変数を用いず、単純に関数のタスクを処理する。
- 可変コンポーネントは変数の状態の変化を許可している。

不変コンポーネントにできるだけ多くの処理を押し込み可変コンポーネントからできるだけ多くのコードを追い払うべきです。

![不変コンポーネントに切り出す](../images/20210728_11.44.png)

## 設計の原則

SOLID 原則についての説明を行う。
SOLID 原則は関数やデータ構図をどのようにクラスに組み込むのか、そして、クラスの相互接続をどのようにするかといったことを教えてくれる原則になっている。
この原則は、オフジェクト指向言語にしか通用しないわけではない。ここで言うクラスとは単にいくつかの機能やデータを取りまとめたものを指している。
SOLID 原則の目的は、以下のような性質を持つ中間レベルのソフトウェア構造（ミドルウェア）を作ることだ。

- 変更に強いこと
- 理解しやすいこと
- コンポーネントの基盤として多くのソフトウェアで利用できること。

「中間レベルの」という言葉は SOLID 原則がモジュールレベルの開発に使われるものであることを意図している。コードレベルよりも上に適応するものであり、モジュールやコンポーネントで使うソフトウェア構造の定義に役立つ。

つまりここでは中間レベルの設計について言及をする。しかしここでよくできた設計ができても全体として、ぐちゃぐちゃな設計になってしまうことがある。
SOLID 原則の説明が終わったら、それに対応するコンポーネントの原則について言及し、最後に上位レベルのアーキテクチャの原則を説明する。

## 単一責任の原則

モジュールはたった 1 つのアクターに対して責務を負うべきという原則のこと。
ここで言うモジュールとはソースファイルのことです。
また、いくつかの関数やデータをまとめた凝集性のあるもの。
凝集性が 1 つのアクターに対する責務を負うコードをまとめるフォースとなる。

## SRP の例

- 想定外の重複
- マージ

## 単一責任の原則まとめ

SRP は、関数や、クラスに関する原則であるが、同じような原則が別のレベルでも登場する。コンポーネントレベルでは、この原則は閉鎖性共通の原則 CCP と呼ばれるようになる。
また、アーキテクチャレベルでは「アーキテクチャの境界」を作るための「変更の軸」と呼ばれている。

## OCP: Open Closed Principle オープン・クローズドの原則

ソフトウェアの構成要素は拡張に対して開いており、修正に対しては閉じていなければならない。

言い換えれば、ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべきであると言うこと。

この原則は、クラスや関数にフォーカスされるが、コンポーネント単位で重要性を発揮する。

## 思考実験

財務情報を Web ページに表示するシステムを考える。

### 用語の整理

- <I> インターフェイス
- <DS> データ構造
- 通常の矢印は、使用の関係
- 白抜きの矢印は、実装や継承の関係

クラス A からクラス B に矢印が伸びている。
これはクラス A がクラス B に依存していることがわかる。つまり、クラス B はクラス A のことを一切知らない。

![コンポーネントの関係は単方向](../images/20210728_22.27.png)

コンポジット図やコンポーネント図の要求インターフェイスと提供インターフェイスは、どちらが上位レベルなのかについて言及している図ではないので注意。
データがどちらからどちらに流れていくのかについて言及されている。

![方向の制御](../images/20210729_08.33.png)

## リスコフの置換原則 Liskov substitution principle

![リスコフの置換原則](../images/20210729_08.44.png)
派生元の型（基底型）と派生先の型（派生型）の間に成り立っていなければならない規則性のことです。

Billing アプリケーションは License のことだけを知っており、それを継承している Personal License と Business License を使うことができる。
これはリスコフの置換原則(LSP)を満たしている。

![正方形・長方形問題](../images/20210729_08.52.png)

この例では Square は Rectangle の適切な派生系ではない。

```swift
var r: Rectangle = Square();
r.setH(2)
r.setW(5)
assert(r.area() == 10)
```

正方形なのに高さと幅が異なっているのはおかしい。
これらの型は置換可能でない。

## LSP とアーキテクチャ

LSP は継承の使い方のみならず、インターフェイスと実装に関するソフトウェア設計の原則になっている。
正方形と長方形の例はリスコフの置換原則を理解するのにはとても良い例です。
